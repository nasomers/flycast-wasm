diff --git a/CMakeLists.txt b/CMakeLists.txt
index 878b5d5..7496f4e 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -186,60 +186,88 @@ if(NINTENDO_SWITCH)
 		IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS)
 
 elseif(LIBRETRO)
-	add_library(${PROJECT_NAME} SHARED core/emulator.cpp)
-	if(APPLE)
-		if(NOT IOS)
-			set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-undefined,error")
-		endif()
-		set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-exported_symbols_list,${CMAKE_CURRENT_SOURCE_DIR}/shell/libretro/libretro.osx.def")
+	if(EMSCRIPTEN)
+		# Emscripten: static library (object files archived later for linking with EmulatorJS RetroArch)
+		add_library(${PROJECT_NAME} STATIC core/emulator.cpp)
+		target_compile_definitions(${PROJECT_NAME} PRIVATE
+			LIBRETRO
+			GLES GLES3 HAVE_OPENGLES HAVE_OPENGLES3 HAVE_OIT)
+		target_compile_options(${PROJECT_NAME} PRIVATE -fexceptions)
+		set_target_properties(${PROJECT_NAME} PROPERTIES OUTPUT_NAME "flycast_libretro_emscripten")
+		# Disable features incompatible with WASM
+		set(USE_VULKAN OFF CACHE BOOL "Force vulkan off" FORCE)
+		set(USE_DX9 OFF CACHE BOOL "Force DX9 off" FORCE)
+		set(USE_DX11 OFF CACHE BOOL "Force DX11 off" FORCE)
+		set(USE_OPENMP OFF CACHE BOOL "Force OpenMP off" FORCE)
+		set(USE_BREAKPAD OFF CACHE BOOL "Force breakpad off" FORCE)
+		set(USE_LUA OFF CACHE BOOL "Force Lua off" FORCE)
+		set(USE_DISCORD OFF CACHE BOOL "Force Discord off" FORCE)
+		# Use GLES3 path for GL symbol loading
+		set(USE_GLES ON CACHE BOOL "Force GLES for Emscripten" FORCE)
+		# asio: disable threads (WASM is single-threaded)
+		target_compile_definitions(${PROJECT_NAME} PRIVATE
+			ASIO_DISABLE_THREADS
+			ASIO_DISABLE_LOCAL_SOCKETS
+			ASIO_DISABLE_SERIAL_PORT)
 	else()
-		if(NOT CMAKE_SYSTEM_NAME STREQUAL "OpenBSD")
-			set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,--no-undefined")
-		endif()
-	endif()
-	set_target_properties(${PROJECT_NAME} PROPERTIES OUTPUT_NAME "flycast_libretro"
-	  XCODE_ATTRIBUTE_CODE_SIGNING_ALLOWED "NO"
-	  XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY ""
-    )
-	set(CMAKE_SHARED_LIBRARY_PREFIX "")
-	set(CMAKE_POSITION_INDEPENDENT_CODE ON)
-	target_compile_definitions(${PROJECT_NAME} PRIVATE LIBRETRO)
-	if(APPLE)
-		find_library(FOUNDATION Foundation)
-		target_link_libraries(${PROJECT_NAME} PRIVATE ${FOUNDATION})
-	endif()
-	if(ANDROID OR USE_GLES)
-		target_compile_definitions(${PROJECT_NAME} PRIVATE GLES GLES3 HAVE_OPENGLES HAVE_OPENGLES3 HAVE_OIT)
-    elseif(IOS)
-		target_compile_definitions(${PROJECT_NAME} PRIVATE GLES GLES3 HAVE_OPENGLES HAVE_OPENGLES3)
-		find_library(OPENGLES OpenGLES)
-		find_library(GLKIT GLKit)
-		target_link_libraries(${PROJECT_NAME} PRIVATE ${OPENGLES} ${GLKIT})
-	elseif(USE_GLES2)
-		target_compile_definitions(${PROJECT_NAME} PRIVATE GLES GLES2 HAVE_OPENGLES HAVE_OPENGLES2)
-		if(USE_VIDEOCORE)
-			target_compile_definitions(${PROJECT_NAME} PRIVATE TARGET_NO_STENCIL)
-			target_link_libraries(${PROJECT_NAME} PRIVATE "-lbrcmGLESv2")
-			target_link_directories(${PROJECT_NAME} PRIVATE "/opt/vc/lib")
+		add_library(${PROJECT_NAME} SHARED core/emulator.cpp)
+		if(APPLE)
+			if(NOT IOS)
+				set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-undefined,error")
+			endif()
+			set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-exported_symbols_list,${CMAKE_CURRENT_SOURCE_DIR}/shell/libretro/libretro.osx.def")
 		else()
-			target_link_libraries(${PROJECT_NAME} PRIVATE "-lGLESv2")
-		endif()
-	elseif(USE_OPENGL)
-		if (CMAKE_SYSTEM_NAME MATCHES "FreeBSD|OpenBSD|NetBSD")
-			find_package(OpenGL REQUIRED)
-			if(CMAKE_VERSION VERSION_LESS 3.29.0)
-				target_include_directories(${PROJECT_NAME} PRIVATE ${OPENGL_INCLUDE_DIR})
-			else()
-				target_include_directories(${PROJECT_NAME} PRIVATE ${OPENGL_INCLUDE_DIRS})
+			if(NOT CMAKE_SYSTEM_NAME STREQUAL "OpenBSD")
+				set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,--no-undefined")
 			endif()
 		endif()
-		target_compile_definitions(${PROJECT_NAME} PRIVATE HAVE_OPENGL)
+		set(CMAKE_SHARED_LIBRARY_PREFIX "")
+		target_compile_definitions(${PROJECT_NAME} PRIVATE LIBRETRO)
 		if(APPLE)
-			set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-framework,OpenGL")
-		else()
-			target_compile_definitions(${PROJECT_NAME} PRIVATE HAVE_OIT)
+			find_library(FOUNDATION Foundation)
+			target_link_libraries(${PROJECT_NAME} PRIVATE ${FOUNDATION})
 		endif()
+		if(ANDROID OR USE_GLES)
+			target_compile_definitions(${PROJECT_NAME} PRIVATE GLES GLES3 HAVE_OPENGLES HAVE_OPENGLES3 HAVE_OIT)
+		elseif(IOS)
+			target_compile_definitions(${PROJECT_NAME} PRIVATE GLES GLES3 HAVE_OPENGLES HAVE_OPENGLES3)
+			find_library(OPENGLES OpenGLES)
+			find_library(GLKIT GLKit)
+			target_link_libraries(${PROJECT_NAME} PRIVATE ${OPENGLES} ${GLKIT})
+		elseif(USE_GLES2)
+			target_compile_definitions(${PROJECT_NAME} PRIVATE GLES GLES2 HAVE_OPENGLES HAVE_OPENGLES2)
+			if(USE_VIDEOCORE)
+				target_compile_definitions(${PROJECT_NAME} PRIVATE TARGET_NO_STENCIL)
+				target_link_libraries(${PROJECT_NAME} PRIVATE "-lbrcmGLESv2")
+				target_link_directories(${PROJECT_NAME} PRIVATE "/opt/vc/lib")
+			else()
+				target_link_libraries(${PROJECT_NAME} PRIVATE "-lGLESv2")
+			endif()
+		elseif(USE_OPENGL)
+			if (CMAKE_SYSTEM_NAME MATCHES "FreeBSD|OpenBSD|NetBSD")
+				find_package(OpenGL REQUIRED)
+				if(CMAKE_VERSION VERSION_LESS 3.29.0)
+					target_include_directories(${PROJECT_NAME} PRIVATE ${OPENGL_INCLUDE_DIR})
+				else()
+					target_include_directories(${PROJECT_NAME} PRIVATE ${OPENGL_INCLUDE_DIRS})
+				endif()
+			endif()
+			target_compile_definitions(${PROJECT_NAME} PRIVATE HAVE_OPENGL)
+			if(APPLE)
+				set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-framework,OpenGL")
+			else()
+				target_compile_definitions(${PROJECT_NAME} PRIVATE HAVE_OIT)
+			endif()
+		endif()
+	endif()
+	if(NOT EMSCRIPTEN)
+		set_target_properties(${PROJECT_NAME} PROPERTIES OUTPUT_NAME "flycast_libretro"
+		  XCODE_ATTRIBUTE_CODE_SIGNING_ALLOWED "NO"
+		  XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY ""
+		)
+		set(CMAKE_SHARED_LIBRARY_PREFIX "")
 	endif()
+	set(CMAKE_POSITION_INDEPENDENT_CODE ON)
 elseif(ANDROID)
 	add_library(${PROJECT_NAME} SHARED core/emulator.cpp)
 	set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_RELEASE} -O3")
@@ -1333,7 +1361,9 @@ if("x86" IN_LIST ARCHITECTURE OR "x86_64" IN_LIST ARCHITECTURE)
 			core/rec-x64/x64_regalloc.h)
 	endif()
 endif()
-
+if(EMSCRIPTEN)
+	target_sources(${PROJECT_NAME} PRIVATE core/rec-wasm/rec_wasm.cpp)
+endif()
 if((USE_OPENGL OR USE_GLES2 OR USE_GLES) AND NOT LIBRETRO)
 	add_library(glad STATIC core/deps/glad/src/gl.c)
 	if(NOT APPLE AND NOT WIN32 AND NOT SDL2_FOUND)
diff --git a/core/build.h b/core/build.h
index 6ea5355..07c7738 100755
--- a/core/build.h
+++ b/core/build.h
@@ -17,6 +17,7 @@
 #define CPU_ARM      0x20000002
 #define CPU_ARM64    0x20000003
 #define CPU_X64      0x20000004
+#define CPU_GENERIC  0x20000005
 
 //FEAT_SHREC, FEAT_AREC, FEAT_DSPREC
 #define DYNAREC_NONE	0x40000001
@@ -24,7 +25,13 @@
 
 //automatic
 
-#if defined(__x86_64__) || defined(_M_X64)
+#if defined(__EMSCRIPTEN__) || defined(__wasm__)
+	#define HOST_CPU CPU_GENERIC
+	// WASM JIT backend
+	#define FEAT_SHREC DYNAREC_JIT
+	#define FEAT_AREC DYNAREC_NONE
+	#define FEAT_DSPREC DYNAREC_NONE
+#elif defined(__x86_64__) || defined(_M_X64)
 	#define HOST_CPU CPU_X64
 #elif defined(__i386__) || defined(_M_IX86)
 	#define HOST_CPU CPU_X86
@@ -48,7 +55,7 @@
 #endif
 
 #if defined(TARGET_NO_REC)
-#define FEAT_SHREC DYNAREC_NONE
+#define FEAT_SHREC DYNAREC_JIT
 #define FEAT_AREC DYNAREC_NONE
 #define FEAT_DSPREC DYNAREC_NONE
 #endif
@@ -69,7 +76,7 @@
 	#if HOST_CPU == CPU_ARM || HOST_CPU == CPU_ARM64 || HOST_CPU == CPU_X86 || HOST_CPU == CPU_X64
 		#define FEAT_SHREC DYNAREC_JIT
 	#else
-		#define FEAT_SHREC DYNAREC_NONE
+		#define FEAT_SHREC DYNAREC_JIT
 	#endif
 #endif
 
diff --git a/core/deps/DreamPicoPort-API b/core/deps/DreamPicoPort-API
--- a/core/deps/DreamPicoPort-API
+++ b/core/deps/DreamPicoPort-API
@@ -1 +1 @@
-Subproject commit e06d9f6c59833fc7bb7f2a33c960614489811ef8
+Subproject commit e06d9f6c59833fc7bb7f2a33c960614489811ef8-dirty
diff --git a/core/deps/SDL b/core/deps/SDL
--- a/core/deps/SDL
+++ b/core/deps/SDL
@@ -1 +1 @@
-Subproject commit 00d4f1c2c4ad2dc95d26b18743541f57b1dca56d
+Subproject commit 00d4f1c2c4ad2dc95d26b18743541f57b1dca56d-dirty
diff --git a/core/hw/mem/addrspace.cpp b/core/hw/mem/addrspace.cpp
index c08cb8e..6d0f86b 100644
--- a/core/hw/mem/addrspace.cpp
+++ b/core/hw/mem/addrspace.cpp
@@ -7,6 +7,9 @@
 #include "oslib/oslib.h"
 #include "oslib/virtmem.h"
 #include <cassert>
+#ifdef __EMSCRIPTEN__
+#include <emscripten.h>
+#endif
 
 namespace addrspace
 {
@@ -410,9 +413,21 @@ void initMappings()
 		WARN_LOG(VMEM, "Warning! nvmem is DISABLED (due to failure or not being built-in");
 
 		// Allocate it all and initialize it.
+#if defined(__EMSCRIPTEN__) && !defined(JIT_PROD_BUILD)
+		EM_ASM({ console.log('[rec_wasm] initMappings: allocating Sh4RCB, size=' + $0); }, (int)sizeof(Sh4RCB));
+#endif
 		p_sh4rcb = (Sh4RCB*)malloc_pages(sizeof(Sh4RCB));
+#if defined(__EMSCRIPTEN__) && !defined(JIT_PROD_BUILD)
+		EM_ASM({ console.log('[rec_wasm] initMappings: p_sh4rcb=' + $0); }, (int)(uintptr_t)p_sh4rcb);
+#endif
 #if FEAT_SHREC != DYNAREC_NONE
+#if defined(__EMSCRIPTEN__) && !defined(JIT_PROD_BUILD)
+		EM_ASM({ console.log('[rec_wasm] initMappings: bm_vmem_pagefill FPCB, size=' + $0); }, (int)sizeof(p_sh4rcb->fpcb));
+#endif
 		bm_vmem_pagefill((void**)p_sh4rcb->fpcb, sizeof(p_sh4rcb->fpcb));
+#if defined(__EMSCRIPTEN__) && !defined(JIT_PROD_BUILD)
+		EM_ASM({ console.log('[rec_wasm] initMappings: bm_vmem_pagefill done'); });
+#endif
 #endif
 		memset(&p_sh4rcb->cntx, 0, sizeof(p_sh4rcb->cntx));
 
diff --git a/core/hw/naomi/naomi.cpp b/core/hw/naomi/naomi.cpp
index abebd4e..3353a36 100644
--- a/core/hw/naomi/naomi.cpp
+++ b/core/hw/naomi/naomi.cpp
@@ -46,8 +46,13 @@ static X76F100SerialFlash romSerialId;
 static int dmaSchedId = -1;
 static int dmaXferDelay = 10;	// cart dma xfer speed, in cycles/byte (default 20 MB/s)
 
+// Diagnostic counters for serial EEPROM access tracking
+u32 g_naomi_board_write_count = 0;
+u32 g_naomi_board_read_count = 0;
+
 void NaomiBoardIDWrite(const u16 data)
 {
+	g_naomi_board_write_count++;
 	// bit 2: clock
 	// bit 3: data
 	// bit 4: reset (x76f100 only)
@@ -60,6 +65,7 @@ void NaomiBoardIDWrite(const u16 data)
 
 u16 NaomiBoardIDRead()
 {
+	g_naomi_board_read_count++;
 	// bit 0 indicates the eeprom is a X76F100, otherwise the BIOS expects an AT93C46
 	// bit 3 is xf76f100 SDA
 	// bit 4 is at93c46 DO
diff --git a/core/hw/pvr/Renderer_if.cpp b/core/hw/pvr/Renderer_if.cpp
index 4fbb9a5..8078666 100644
--- a/core/hw/pvr/Renderer_if.cpp
+++ b/core/hw/pvr/Renderer_if.cpp
@@ -14,6 +14,10 @@
 #include <mutex>
 #include <deque>
 
+#ifdef __EMSCRIPTEN__
+#include <emscripten.h>
+#endif
+
 #ifdef LIBRETRO
 void retro_rend_present();
 void retro_resize_renderer(int w, int h, float aspectRatio);
@@ -242,7 +246,18 @@ private:
 	{
 		FC_PROFILE_SCOPE;
 
+#if defined(__EMSCRIPTEN__) && !defined(JIT_PROD_BUILD)
+		static int present_count = 0;
+		present_count++;
+		bool presResult = renderer->Present();
+		if (present_count <= 5) {
+			EM_ASM({ console.log('[rend] present #' + $0 + ': Present()=' + $1 + ' threaded=' + $2); },
+				present_count, presResult ? 1 : 0, (int)config::ThreadedRendering);
+		}
+		if (presResult)
+#else
 		if (renderer->Present())
+#endif
 		{
 			presented = true;
 			if (!config::ThreadedRendering && !ggpo::active())
@@ -457,6 +472,21 @@ int rend_end_render(int tag, int cycles, int jitter, void *arg)
 
 void rend_vblank()
 {
+#if defined(__EMSCRIPTEN__) && !defined(JIT_PROD_BUILD)
+	static int vblank_count = 0;
+	static int last_fb_enable = -1;
+	static int last_fb_dirty = -1;
+	vblank_count++;
+	int cur_fb_enable = (int)FB_R_CTRL.fb_enable;
+	int cur_fb_dirty = (int)fb_dirty;
+	// Log on change or every 30 vblanks
+	if (cur_fb_enable != last_fb_enable || cur_fb_dirty != last_fb_dirty || (vblank_count % 30) == 0) {
+		EM_ASM({ console.log('[rend] vblank #' + $0 + ': fb_dirty=' + $1 + ' fb_enable=' + $2 + ' render_called=' + $3 + ' rend_enabled=' + $4); },
+			vblank_count, cur_fb_dirty, cur_fb_enable, (int)render_called, (int)rend_is_enabled());
+		last_fb_enable = cur_fb_enable;
+		last_fb_dirty = cur_fb_dirty;
+	}
+#endif
 	if (config::EmulateFramebuffer
 			|| (!render_called && fb_dirty && FB_R_CTRL.fb_enable))
 	{
diff --git a/core/hw/pvr/pvr_mem.cpp b/core/hw/pvr/pvr_mem.cpp
index 4b809d6..77225c7 100644
--- a/core/hw/pvr/pvr_mem.cpp
+++ b/core/hw/pvr/pvr_mem.cpp
@@ -102,6 +102,15 @@ static void YUV_ConvertMacroBlock(const u8 *datap)
 
 	YUV_Block384(datap, &vram[YUV_dest]);
 
+	// Check framebuffer watch range for YUV macroblock write
+	// YUV_Block384 writes a 16x16 macroblock starting at YUV_dest
+	{
+		u32 yuv_start = YUV_dest;
+		u32 yuv_end = YUV_dest + YUV_x_size * 16 * 2;  // 16 rows, 2 bytes/pixel
+		if (yuv_start < fb_watch_addr_end && yuv_end > fb_watch_addr_start)
+			fb_dirty = true;
+	}
+
 	YUV_dest+=32;
 
 	YUV_x_curr+=16;
@@ -270,8 +279,12 @@ void DYNACALL TAWriteSQ(u32 address, const SQBuffer *sqb)
 		if (path64b)
 		{
 			// 64b path
-			SQBuffer *dest = (SQBuffer *)&vram[address_w & VRAM_MASK];
+			u32 vaddr = address_w & VRAM_MASK;
+			SQBuffer *dest = (SQBuffer *)&vram[vaddr];
 			*dest = *sq;
+			// Check framebuffer watch range (32-byte SQ write)
+			if (vaddr < fb_watch_addr_end && (vaddr + sizeof(SQBuffer)) > fb_watch_addr_start)
+				fb_dirty = true;
 		}
 		else
 		{
@@ -325,8 +338,12 @@ void DYNACALL pvr_write_area4(u32 addr, T data)
 	bool access32 = (upper ? SB_LMMODE1 : SB_LMMODE0) == 1;
 	if (access32)
 		pvr_write32p(addr, data);
-	else
-		*(T*)&vram[addr & VRAM_MASK] = data;
+	else {
+		u32 vaddr = addr & VRAM_MASK;
+		*(T*)&vram[vaddr] = data;
+		if (vaddr >= fb_watch_addr_start && vaddr < fb_watch_addr_end)
+			fb_dirty = true;
+	}
 }
 template void pvr_write_area4<u8, false>(u32 addr, u8 data);
 template void pvr_write_area4<u16, false>(u32 addr, u16 data);
diff --git a/core/hw/pvr/pvr_regs.cpp b/core/hw/pvr/pvr_regs.cpp
index 0538b3c..3ef7772 100644
--- a/core/hw/pvr/pvr_regs.cpp
+++ b/core/hw/pvr/pvr_regs.cpp
@@ -4,6 +4,11 @@
 #include "ta.h"
 #include "spg.h"
 #include <map>
+#ifdef __EMSCRIPTEN__
+#include <emscripten.h>
+#include "hw/sh4/sh4_core.h"  // for Sh4cntx (sh4ctx->pc)
+extern u32 g_wasm_block_count;
+#endif
 
 bool pal_needs_update=true;
 
@@ -129,6 +134,16 @@ void pvr_WriteReg(u32 paddr,u32 data)
 		return; // read only
 
 	case STARTRENDER_addr:
+#if defined(__EMSCRIPTEN__) && !defined(JIT_PROD_BUILD)
+		{
+			static int startrender_count = 0;
+			startrender_count++;
+			EM_ASM({ console.log('[STARTRENDER] #' + $0 +
+				' blk=' + $1 +
+				' pc=0x' + ($2>>>0).toString(16)); },
+				startrender_count, g_wasm_block_count, p_sh4rcb->cntx.pc);
+		}
+#endif
 		rend_start_render();
 		YUV_init();
 		return;
@@ -163,6 +178,21 @@ void pvr_WriteReg(u32 paddr,u32 data)
 
 	case FB_R_CTRL_addr:
 		{
+#if defined(__EMSCRIPTEN__) && !defined(JIT_PROD_BUILD)
+			static int fb_r_ctrl_write_count = 0;
+			fb_r_ctrl_write_count++;
+			u32 old_val = PvrReg(addr, u32);
+			u32 sh4_pc = p_sh4rcb->cntx.pc;
+			// Log ALL writes to FB_R_CTRL with block count and SH4 PC
+			EM_ASM({ console.log('[FB_R_CTRL-WR] #' + $0 +
+				' blk=' + $1 +
+				' pc=0x' + ($2>>>0).toString(16) +
+				' old=0x' + ($3>>>0).toString(16) +
+				' new=0x' + ($4>>>0).toString(16) +
+				' fb_enable: ' + ($3 & 1) + '->' + ($4 & 1)); },
+				fb_r_ctrl_write_count, g_wasm_block_count, sh4_pc,
+				old_val, data);
+#endif
 			bool vclk_div_changed = (PvrReg(addr, u32) ^ data) & (1 << 23);
 			PvrReg(addr, u32) = data;
 			if (vclk_div_changed)
diff --git a/core/hw/sh4/dyna/decoder.cpp b/core/hw/sh4/dyna/decoder.cpp
index 1fff5ee..5803344 100644
--- a/core/hw/sh4/dyna/decoder.cpp
+++ b/core/hw/sh4/dyna/decoder.cpp
@@ -997,7 +997,7 @@ bool dec_DecodeBlock(RuntimeBlockInfo* rbi,u32 max_cycles)
 
 					if (state.cpu.is_delayslot && OpDesc[op]->SetPC())
 						throw FlycastException("Fatal: SH4 branch instruction in delay slot");
-					if (!OpDesc[op]->rec_oph)
+						if (!OpDesc[op]->rec_oph)
 					{
 						if (!dec_generic(op))
 						{
diff --git a/core/hw/sh4/dyna/driver.cpp b/core/hw/sh4/dyna/driver.cpp
index 4e1fbf3..54ae21f 100644
--- a/core/hw/sh4/dyna/driver.cpp
+++ b/core/hw/sh4/dyna/driver.cpp
@@ -1,6 +1,10 @@
 #include "types.h"
 #include <unordered_set>
 
+#ifdef __EMSCRIPTEN__
+#include <emscripten.h>
+#endif
+
 #include "hw/sh4/sh4_interpreter.h"
 #include "hw/sh4/sh4_core.h"
 #include "hw/sh4/sh4_interrupts.h"
@@ -15,6 +19,10 @@
 
 #if FEAT_SHREC != DYNAREC_NONE
 
+#if defined(__EMSCRIPTEN__) && HOST_CPU == CPU_GENERIC
+extern "C" void wasm_dynarec_init();
+#endif
+
 constexpr u32 CODE_SIZE = 10_MB;
 constexpr u32 TEMP_CODE_SIZE = 1_MB;
 constexpr u32 FULL_SIZE = CODE_SIZE + TEMP_CODE_SIZE;
@@ -342,26 +350,54 @@ void Sh4Recompiler::Reset(bool hard)
 void Sh4Recompiler::Init()
 {
 	INFO_LOG(DYNAREC, "Sh4Recompiler::Init");
+#if defined(__EMSCRIPTEN__) && !defined(JIT_PROD_BUILD)
+	EM_ASM({ console.log('[rec_wasm] Sh4Recompiler::Init() — step 1: super::Init()'); });
+#endif
 	super::Init();
+#if defined(__EMSCRIPTEN__) && !defined(JIT_PROD_BUILD)
+	EM_ASM({ console.log('[rec_wasm] Sh4Recompiler::Init() — step 2: bm_Init()'); });
+#endif
 	bm_Init();
-	
+
 	if (addrspace::virtmemEnabled())
 		verify(&mem_b[0] == ((u8*)getContext()->sq_buffer + sizeof(Sh4Context) + 0x0C000000));
 
+#if defined(__EMSCRIPTEN__) && !defined(JIT_PROD_BUILD)
+	EM_ASM({ console.log('[rec_wasm] Sh4Recompiler::Init() — step 3: prepare_jit_block()'); });
+#endif
 	// Call the platform-specific magic to make the pages RWX
 	CodeCache = nullptr;
 #ifdef FEAT_NO_RWX_PAGES
 	bool rc = virtmem::prepare_jit_block(SH4_TCB, FULL_SIZE, (void**)&CodeCache, &cc_rx_offset);
 #else
 	bool rc = virtmem::prepare_jit_block(SH4_TCB, FULL_SIZE, (void**)&CodeCache);
+#endif
+#if defined(__EMSCRIPTEN__) && !defined(JIT_PROD_BUILD)
+	EM_ASM({ console.log('[rec_wasm] Sh4Recompiler::Init() — step 3 result: rc=' + $0 + ' CodeCache=' + $1); }, (int)rc, (int)(uintptr_t)CodeCache);
 #endif
 	verify(rc);
 	// Ensure the pointer returned is non-null
 	verify(CodeCache != nullptr);
 
 	TempCodeCache = CodeCache + CODE_SIZE;
+#if defined(__EMSCRIPTEN__) && HOST_CPU == CPU_GENERIC
+	// Ensure WASM dynarec is initialized — the static constructor may not have
+	// run if the linker stripped the translation unit from the archive.
+	wasm_dynarec_init();
+#endif
+#if defined(__EMSCRIPTEN__) && !defined(JIT_PROD_BUILD)
+	EM_ASM({ console.log('[rec_wasm] Sh4Recompiler::Init() — step 4: sh4Dynarec->init(), sh4Dynarec=' + $0 + ' ctx=' + $1); },
+		(int)(uintptr_t)sh4Dynarec, (int)(uintptr_t)getContext());
+#endif
+	verify(sh4Dynarec != nullptr);
 	sh4Dynarec->init(*getContext(), codeBuffer);
+#if defined(__EMSCRIPTEN__) && !defined(JIT_PROD_BUILD)
+	EM_ASM({ console.log('[rec_wasm] Sh4Recompiler::Init() — step 5: bm_ResetCache()'); });
+#endif
 	bm_ResetCache();
+#if defined(__EMSCRIPTEN__) && !defined(JIT_PROD_BUILD)
+	EM_ASM({ console.log('[rec_wasm] Sh4Recompiler::Init() — COMPLETE'); });
+#endif
 }
 
 void Sh4Recompiler::Term()
diff --git a/core/hw/sh4/dyna/shil_canonical.h b/core/hw/sh4/dyna/shil_canonical.h
index a1be200..3727ab8 100644
--- a/core/hw/sh4/dyna/shil_canonical.h
+++ b/core/hw/sh4/dyna/shil_canonical.h
@@ -747,6 +747,22 @@ u32,f1,(f32 f1),
 	}
 	return res;
 )
+#else
+// CPU_GENERIC (Emscripten/WASM) — same behavior as ARM (NaN → 0x80000000)
+shil_canonical
+(
+u32,f1,(f32 f1),
+	s32 res;
+	if (f1 > 2147483520.0f) {
+		res = 0x7fffffff;
+	}
+	else {
+		res = (s32)f1;
+		if (std::isnan(f1))
+			res = 0x80000000;
+	}
+	return res;
+)
 #endif
 
 shil_compile
diff --git a/core/hw/sh4/dyna/ssa.cpp b/core/hw/sh4/dyna/ssa.cpp
index 85c1fdf..a62439b 100644
--- a/core/hw/sh4/dyna/ssa.cpp
+++ b/core/hw/sh4/dyna/ssa.cpp
@@ -489,6 +489,11 @@ void SSAOptimizer::ConstPropPass()
 				// and if those pages are read-only, then we can directly read the memory at compile time
 				// and propagate the read value as a constant.
 				if (op.op == shop_readm  && block->read_only
+#ifdef __EMSCRIPTEN__
+						&& false  // WASM: mprotect is a no-op, so read-only pages
+						          // aren't actually protected. Compile-time reads
+						          // become stale when the page is written to.
+#endif
 						&& (op.rs1._imm >> 12) >= (block->vaddr >> 12)
 						&& (op.rs1._imm >> 12) <= ((block->vaddr + block->sh4_code_size - 1) >> 12)
 						&& op.size <= 4)
diff --git a/core/hw/sh4/sh4_core_regs.cpp b/core/hw/sh4/sh4_core_regs.cpp
index 7542f13..bfaec7d 100644
--- a/core/hw/sh4/sh4_core_regs.cpp
+++ b/core/hw/sh4/sh4_core_regs.cpp
@@ -120,6 +120,10 @@ static void setHostRoundingMode(u32 roundingMode, u32 denorm2zero)
                 : "r"(off_mask), "r"(on_mask)
 				: "x10"
             );
+    #elif defined(__EMSCRIPTEN__) || defined(__wasm__) || HOST_CPU == CPU_GENERIC
+		// WASM/generic: no hardware FPU control — rounding mode is not configurable
+		(void)roundingMode;
+		(void)denorm2zero;
     #else
 	#error "SetFloatStatusReg: Unsupported platform"
     #endif
diff --git a/core/linux/context.cpp b/core/linux/context.cpp
index 461ff26..a8ba32c 100644
--- a/core/linux/context.cpp
+++ b/core/linux/context.cpp
@@ -130,6 +130,10 @@ static void context_segfault(host_context_t* hostctx, void* segfault_ctx)
     #else
         #error "Unsupported OS"
 	#endif
+#elif HOST_CPU == CPU_GENERIC
+	// No segfault context handling for generic/WASM platform (interpreter only)
+	(void)hostctx;
+	(void)segfault_ctx;
 #else
 	#error Unsupported HOST_CPU
 #endif
diff --git a/core/linux/posix_vmem.cpp b/core/linux/posix_vmem.cpp
index 4610515..f52ac64 100644
--- a/core/linux/posix_vmem.cpp
+++ b/core/linux/posix_vmem.cpp
@@ -4,7 +4,7 @@
 // Android and OSX since they are slightly different in some areas.
 #include "types.h"
 
-#ifndef __SWITCH__
+#if !defined(__SWITCH__) && !defined(__EMSCRIPTEN__)
 #include <sys/mman.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -326,7 +326,50 @@ void release_jit_block(void *code_area1, void *code_area2, size_t size)
 
 } // namespace virtmem
 
-#endif // !__SWITCH__
+#endif // !__SWITCH__ && !__EMSCRIPTEN__
+
+#ifdef __EMSCRIPTEN__
+// Emscripten: no mmap/shm_open/mprotect support.
+// All virtmem functions are no-ops. addrspace::initMappings() will use
+// the malloc-based fallback path when virtmem::init() returns false.
+#include "hw/mem/addrspace.h"
+#include "hw/sh4/sh4_if.h"
+#include "oslib/virtmem.h"
+
+namespace virtmem
+{
+
+bool region_lock(void *start, size_t len) { return true; }
+bool region_unlock(void *start, size_t len) { return true; }
+bool region_set_exec(void *start, size_t len) { return true; }
+bool init(void **vmem_base_addr, void **sh4rcb_addr, size_t ramSize) { return false; }
+void destroy() {}
+void reset_mem(void *ptr, unsigned size_bytes) { memset(ptr, 0, size_bytes); }
+void ondemand_page(void *address, unsigned size_bytes) {}
+void create_mappings(const Mapping *vmem_maps, unsigned nummaps) {}
+bool prepare_jit_block(void *code_area, size_t size, void **code_area_rwx) {
+	// WASM JIT: no native code execution, but we need a valid buffer for the block manager
+	// Allocate a dummy buffer — rec_wasm doesn't write native code into it, but driver.cpp expects non-null
+	static u8* wasmJitBuffer = nullptr;
+	if (!wasmJitBuffer)
+		wasmJitBuffer = (u8*)malloc(size);
+	if (!wasmJitBuffer)
+		return false;
+	memset(wasmJitBuffer, 0, size);
+	*code_area_rwx = wasmJitBuffer;
+	return true;
+}
+bool prepare_jit_block(void *code_area, size_t size, void **code_area_rw, ptrdiff_t *rx_offset) {
+	bool rc = prepare_jit_block(code_area, size, code_area_rw);
+	if (rc && rx_offset)
+		*rx_offset = 0;
+	return rc;
+}
+void release_jit_block(void *code_area, size_t size) { /* buffer is static, leaked intentionally */ }
+void release_jit_block(void *code_area1, void *code_area2, size_t size) {}
+
+} // namespace virtmem
+#endif // __EMSCRIPTEN__
 
 namespace virtmem
 {
diff --git a/core/oslib/virtmem.h b/core/oslib/virtmem.h
index 143d093..5b72309 100644
--- a/core/oslib/virtmem.h
+++ b/core/oslib/virtmem.h
@@ -1,7 +1,10 @@
 #pragma once
 #include "types.h"
 
-#if defined(_WIN32) || defined(TARGET_IPHONE) || defined(TARGET_ARM_MAC)
+#if defined(__EMSCRIPTEN__)
+// Emscripten: no native code execution. Use a pointer (allocated via malloc in prepare_jit_block).
+#define DECLARE_CODE_CACHE(Name, Size) static u8 *Name;
+#elif defined(_WIN32) || defined(TARGET_IPHONE) || defined(TARGET_ARM_MAC)
 #define DECLARE_CODE_CACHE(Name, Size) static u8 *Name;
 #elif defined(__ANDROID__)
 #define DECLARE_CODE_CACHE(Name, Size) alignas(4096) static u8 Name[Size];
diff --git a/core/rend/gles/gles.cpp b/core/rend/gles/gles.cpp
index d395d67..8bd9bdd 100644
--- a/core/rend/gles/gles.cpp
+++ b/core/rend/gles/gles.cpp
@@ -521,7 +521,14 @@ void findGLVersion()
 			if (gl.gl_major > 3 || gl.gl_minor >= 2)
 		    	gl.border_clamp_supported = true;
 			gl.prim_restart_supported = false;
+#ifdef __EMSCRIPTEN__
+			// WebGL2 doesn't support GL_PRIMITIVE_RESTART_FIXED_INDEX —
+			// glEnable() returns INVALID_ENUM. Primitive restart is always
+			// active in WebGL2 (spec §5.18), so no enable call needed.
+			gl.prim_restart_fixed_supported = false;
+#else
 			gl.prim_restart_fixed_supported = true;
+#endif
 			gl.single_channel_format = GL_RED;
 		}
 		else
diff --git a/core/ui/gui.cpp b/core/ui/gui.cpp
index 0f29057..4f87441 100644
--- a/core/ui/gui.cpp
+++ b/core/ui/gui.cpp
@@ -17,6 +17,9 @@
     along with Flycast.  If not, see <https://www.gnu.org/licenses/>.
  */
 #include "gui.h"
+#ifdef __EMSCRIPTEN__
+#include <emscripten.h>
+#endif
 #include "rend/osd.h"
 #include "cfg/cfg.h"
 #include "imgui.h"
@@ -1716,6 +1719,11 @@ void fatal_error(const char* text, ...)
     vsnprintf(temp, sizeof(temp), text, args);
     va_end(args);
     ERROR_LOG(COMMON, "%s", temp);
+#ifdef __EMSCRIPTEN__
+    // Make fatal errors visible in browser console (ERROR_LOG and os_notify
+    // don't reach console.log on Emscripten)
+    EM_ASM({ console.error('[FATAL] ' + UTF8ToString($0)); }, temp);
+#endif
 
     os_notify("Fatal Error", 20000, temp);
 }
diff --git a/shell/cmake/DetectArchitecture.cmake b/shell/cmake/DetectArchitecture.cmake
index 9a4b855..031fd86 100644
--- a/shell/cmake/DetectArchitecture.cmake
+++ b/shell/cmake/DetectArchitecture.cmake
@@ -21,6 +21,9 @@ function(detect_architecture symbol arch)
     endif()
 endfunction()
 
+detect_architecture("__EMSCRIPTEN__" wasm32)
+detect_architecture("__wasm__" wasm32)
+
 detect_architecture("__ARM64__" arm64)
 detect_architecture("__aarch64__" arm64)
 detect_architecture("_M_ARM64" arm64)
diff --git a/shell/libretro/audiostream.cpp b/shell/libretro/audiostream.cpp
index 63fe0a4..2c3208a 100644
--- a/shell/libretro/audiostream.cpp
+++ b/shell/libretro/audiostream.cpp
@@ -71,9 +71,12 @@ void retro_audio_init(void)
 	 * but must limit the total number of samples that can be
 	 * uploaded since the libretro frontend can 'hang' if too
 	 * many samples are sent during a single call of retro_run().
-	 * We therefore (arbitrarily) choose to allow up to 10 frames
-	 * worth of 'worst case' stereo samples... */
+	 * WASM: compile stalls can be longer, so allow 20 frames. */
+#ifdef __EMSCRIPTEN__
+	size_t audio_buffer_size = (44100 / 25) * 2 * 20;
+#else
 	size_t audio_buffer_size = (44100 / 25) * 2 * 10;
+#endif
 
 	audio_buffer.resize(audio_buffer_size);
 	audio_buffer_idx = 0;
@@ -117,6 +120,20 @@ void retro_audio_flush_buffer(void)
 	drop_samples = false;
 }
 
+size_t retro_audio_buffer_fill(void)
+{
+	/* Returns current buffer fill in stereo frames (sample pairs).
+	 * Used by the frame pacer's PI controller to sync emulation speed
+	 * to audio consumption rate. Lock-free read is acceptable here
+	 * since we only need an approximate value. */
+	return audio_buffer_idx >> 1;
+}
+
+size_t retro_audio_buffer_capacity(void)
+{
+	return audio_buffer.size() >> 1;
+}
+
 void retro_audio_upload(void)
 {
 	audio_buffer_mutex.lock();
@@ -200,12 +217,15 @@ void retro_audio_upload(void)
 		size_t frames_written = audio_batch_cb(audio_out_buffer_ptr,
 				frames_to_write);
 
-		if ((frames_written < frames_to_write) &&
-			 (frames_written > 0))
+		if (frames_written == 0)
+			break;  // frontend can't accept more — stop instead of looping
+
+		if (frames_written < frames_to_write)
 			audio_batch_frames_max = frames_written;
 
-		num_frames -= frames_to_write;
-		audio_out_buffer_ptr += frames_to_write << 1;
+		// Only advance by what was actually written, not what was offered
+		num_frames -= frames_written;
+		audio_out_buffer_ptr += frames_written << 1;
 	}
 }
 
@@ -218,13 +238,15 @@ void WriteSample(s16 r, s16 l)
 
 	if (audio_buffer.size() < audio_buffer_idx + 2)
 	{
-		/* Audio buffer overflow...
-		 * > Drop any existing samples
-		 * > Drop any future samples until the next
-		 *   call of retro_audio_upload() */
-		audio_buffer_idx = 0;
-		drop_samples = true;
-		return;
+		/* Audio buffer overflow — keep the newest half of samples
+		 * instead of nuking everything. This preserves audio continuity
+		 * across compile stalls and timing hiccups. */
+		size_t keep = audio_buffer_idx / 2;
+		keep &= ~(size_t)1;  // align to stereo pairs
+		size_t discard = audio_buffer_idx - keep;
+		if (keep > 0)
+			memmove(audio_buffer.data(), audio_buffer.data() + discard, keep * sizeof(int16_t));
+		audio_buffer_idx = keep;
 	}
 
 	audio_buffer[audio_buffer_idx++] = l;
diff --git a/shell/libretro/libretro.cpp b/shell/libretro/libretro.cpp
index 9dcc6b3..e08ec78 100644
--- a/shell/libretro/libretro.cpp
+++ b/shell/libretro/libretro.cpp
@@ -18,6 +18,9 @@
 #include <cstdarg>
 #include <math.h>
 #include "types.h"
+#ifdef __EMSCRIPTEN__
+#include <emscripten.h>
+#endif
 #ifndef _WIN32
 #include <sys/time.h>
 #endif
@@ -110,6 +113,8 @@ extern void retro_audio_init(void);
 extern void retro_audio_deinit(void);
 extern void retro_audio_flush_buffer(void);
 extern void retro_audio_upload(void);
+extern size_t retro_audio_buffer_fill(void);
+extern size_t retro_audio_buffer_capacity(void);
 
 std::string arcadeFlashPath;
 
@@ -1156,6 +1161,13 @@ static void update_variables(bool first_startup)
 
 	set_variable_visibility();
 
+#ifdef __EMSCRIPTEN__
+	// WASM without pthreads: force single-threaded rendering.
+	// ThreadedRendering causes retro_run() to loop up to 5 emu frames
+	// trying to produce a non-dupe, creating massive pacing variance.
+	config::ThreadedRendering = false;
+#endif
+
 	if (!first_startup)
 	{
 		if (wasThreadedRendering != config::ThreadedRendering)
@@ -1198,6 +1210,125 @@ static void update_variables(bool first_startup)
 
 void retro_run()
 {
+#ifdef __EMSCRIPTEN__
+	// Fixed-step accumulator frame pacer with audio-driven PI governor.
+	// Base target: DC native vblank rate (59.94 NTSC / 50 PAL).
+	// PI controller adjusts target_ms by +/- small amount to keep the
+	// audio buffer near its ideal fill level. This prevents audio
+	// starvation (crackling) and overflow (drops) by treating audio
+	// consumption as the authoritative clock.
+	{
+		static double accumulator = 0;
+		static double prev_time = 0;
+		static int frame_count = 0;
+		static double hud_last_update = 0;
+		static double frame_time_min = 999;
+		static double frame_time_max = 0;
+		static double frame_time_sum = 0;
+
+		// PI controller state
+		static double pi_integral = 0;
+		static double pi_adjust_ms = 0;
+
+		// Base DC refresh
+		double base_fps = SPG_CONTROL.isPAL() ? 50.0 : 59.94;
+		double nominal_ms = 1000.0 / base_fps;
+
+		// Audio-driven PI controller: adjust target_ms to match audio drain rate.
+		// Target fill: 1 frame's worth of audio (~735 stereo frames at 60fps/44100Hz).
+		// If buffer is overfull, we're producing too fast -> increase target_ms (slow down).
+		// If buffer is underfull, we're producing too slow -> decrease target_ms (speed up).
+		{
+			double samples_per_vblank = 44100.0 / base_fps;  // ~735
+			double target_fill = samples_per_vblank;  // 1 frame buffered
+			double current_fill = (double)retro_audio_buffer_fill();
+
+			// Error: positive = too much audio (slow down), negative = too little (speed up)
+			double error = current_fill - target_fill;
+
+			// PI gains (tuned conservatively to avoid oscillation)
+			const double Kp = 0.0005;   // proportional: 0.5ms per 1000 excess samples
+			const double Ki = 0.00002;  // integral: slow drift correction
+			const double max_integral = 3.0;  // clamp integral windup
+			const double max_adjust = 2.0;    // max +/- 2ms (~12% of 16.68ms)
+
+			pi_integral += error;
+			if (pi_integral > max_integral / Ki) pi_integral = max_integral / Ki;
+			if (pi_integral < -max_integral / Ki) pi_integral = -max_integral / Ki;
+
+			pi_adjust_ms = Kp * error + Ki * pi_integral;
+			if (pi_adjust_ms > max_adjust) pi_adjust_ms = max_adjust;
+			// Only allow positive adjustment (slow down). Never speed up
+			// past native DC rate — overspeed is worse than slight underspeed.
+			if (pi_adjust_ms < 0) pi_adjust_ms = 0;
+		}
+
+		double target_ms = nominal_ms + pi_adjust_ms;
+		// Never run faster than native DC speed — PI can only slow down
+		if (target_ms < nominal_ms) target_ms = nominal_ms;
+
+		double now = emscripten_get_now();
+		double elapsed = (prev_time > 0) ? (now - prev_time) : 0;
+		prev_time = now;
+
+		accumulator += elapsed;
+
+		// Spiral protection: if we've fallen behind by more than 1 frame,
+		// clamp to 1 frame of catch-up and reset integral.
+		// Allowing >1 frame catch-up causes visible overspeed bursts.
+		if (accumulator > target_ms * 2.0) {
+			accumulator = target_ms;
+			pi_integral = 0;
+		}
+
+		// Not enough time accumulated for a frame
+		if (accumulator < target_ms) {
+			video_cb(0, framebufferWidth, framebufferHeight, 0);
+			return;
+		}
+
+		// Consume one frame's worth of time
+		accumulator -= target_ms;
+
+		// Track frame-to-frame timing
+		if (elapsed > 0) {
+			frame_time_sum += elapsed;
+			if (elapsed < frame_time_min) frame_time_min = elapsed;
+			if (elapsed > frame_time_max) frame_time_max = elapsed;
+		}
+		frame_count++;
+
+		// HUD: EMU fps/target + audio fill + PI adjust + frame timing
+		if (hud_last_update == 0) hud_last_update = now;
+		if (now - hud_last_update >= 1000.0) {
+			double avg_ft = (frame_count > 0) ? (frame_time_sum / frame_count) : 0;
+			size_t abuf = retro_audio_buffer_fill();
+			EM_ASM({
+				var el = document.getElementById('fc-hud');
+				if (!el) {
+					el = document.createElement('div');
+					el.id = 'fc-hud';
+					el.style.cssText = 'position:fixed;top:8px;left:8px;z-index:99999;'
+						+ 'background:rgba(0,0,0,0.7);color:#fff;font:12px monospace;'
+						+ 'padding:4px 8px;pointer-events:none;border-radius:3px;';
+					document.body.appendChild(el);
+				}
+				var adj = $5 >= 0 ? '+' + $5.toFixed(1) : $5.toFixed(1);
+				el.textContent = 'EMU:' + $0 + '/' + $1.toFixed(0)
+					+ ' aud:' + $6
+					+ ' pi:' + adj + 'ms'
+					+ ' ft:' + $2.toFixed(0) + '/' + $3.toFixed(0) + '/' + $4.toFixed(0);
+			}, frame_count, base_fps, frame_time_min, avg_ft, frame_time_max,
+			   pi_adjust_ms, (int)abuf);
+			frame_count = 0;
+			frame_time_min = 999;
+			frame_time_max = 0;
+			frame_time_sum = 0;
+			hud_last_update = now;
+		}
+	}
+#endif
+
 	bool updated = false;
 	if (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE_UPDATE, &updated) && updated)
 		update_variables(false);
@@ -1275,6 +1406,22 @@ void retro_run()
 		environ_cb(RETRO_ENVIRONMENT_SET_SYSTEM_AV_INFO, &avinfo);
 	}
 
+#if defined(__EMSCRIPTEN__) && !defined(JIT_PROD_BUILD)
+	{
+		static int videocb_count = 0;
+		static int first_non_dupe = 0;
+		videocb_count++;
+		if (!is_dupe && first_non_dupe == 0) {
+			first_non_dupe = videocb_count;
+			EM_ASM({ console.log('[retro] FIRST REAL FRAME at video_cb #' + $0 + ' w=' + $1 + ' h=' + $2); },
+				videocb_count, framebufferWidth, framebufferHeight);
+		}
+		if (videocb_count <= 5 || (videocb_count % 10) == 0) {
+			EM_ASM({ console.log('[retro] video_cb #' + $0 + ': is_dupe=' + $1 + ' w=' + $2 + ' h=' + $3); },
+				videocb_count, is_dupe ? 1 : 0, framebufferWidth, framebufferHeight);
+		}
+	}
+#endif
 	video_cb(is_dupe ? 0 : RETRO_HW_FRAME_BUFFER_VALID, framebufferWidth, framebufferHeight, 0);
 
 	if (!config::ThreadedRendering || config::LimitFPS)
@@ -3579,24 +3726,30 @@ static void retro_keyboard_event(bool down, unsigned keycode, uint32_t character
 
 void fatal_error(const char* text, ...)
 {
+	va_list args;
+	char temp[2048];
+	va_start(args, text);
+	vsprintf(temp, text, args);
+	va_end(args);
+	strcat(temp, "\n");
 	if (log_cb)
-	{
-		va_list args;
-		char temp[2048];
-		va_start(args, text);
-		vsprintf(temp, text, args);
-		va_end(args);
-		strcat(temp, "\n");
 		log_cb(RETRO_LOG_ERROR, temp);
-	}
+#ifdef __EMSCRIPTEN__
+	EM_ASM({ console.error('[FATAL] ' + UTF8ToString($0)); }, temp);
+#endif
 }
 
 [[noreturn]] void os_DebugBreak()
 {
 	ERROR_LOG(COMMON, "DEBUGBREAK!");
+#ifdef __EMSCRIPTEN__
+	EM_ASM({ console.error('[os_DebugBreak] called! Stack: ' + new Error().stack); });
+#endif
 	//exit(-1);
 #ifdef __SWITCH__
 	svcExitProcess();
+#elif defined(__EMSCRIPTEN__)
+	abort();
 #else
 	__builtin_trap();
 #endif
